#+INCLUDE: ohjelmointi-kappaleiden-yhteiset-asetukset.org

* Lauselohko
** Esimerkki
  Kirjoitetaan ohjelma, joka piirtää piirtoikkunan keskelle ympyrän
  seuraavasti.
  - Jos ikkunan leveys on suurempi kuin korkeus, piirretään mustalle
    taustalle ympyrä, jonka halkaisija on 100.
  - Muussa tapauksessa piirretään siniselle pohjalle ympyrä, jonka
    halkaisija on 50.

  Muistamme, että ~if-else~-rakenne näyttää seuraavalta.
  #+BEGIN_EXAMPLE
  if (ehto)
    lauseke, joka suoritetaan jos ehto tosi;
  else
    lauseke, joka suoritetaan jos ehto ei ole tosi;
  #+END_EXAMPLE
  Suunnittelemassamme ohjelmassa ehto vaikuttaa kahteen asiaan: sekä
  taustaväriin että ympyrän halkaisijaan. Ehdon ollessa tosi halutaan
  siis suorittaa useampi lauseke.
  
  Ohjelma voidaan kirjoittaa /lauselohkojen/ avulla.

  #+BEGIN_QUOTE
  Lauselohko alkaa ~{~-merkillä ja päättyy
  ~}~-merkkiin. ~if-else~-rakenteessa lauselohkot näyttävät
  seuraavilta.
  #+BEGIN_EXAMPLE
  if (ehto)
  {
    lauseke;
    toinen lauseke;
    ...
    viimeinen lauseke;
  }
  else
  {
    lauseke;
    toinen lauseke;
    ...
    viimeinen lauseke;
  }
  #+END_EXAMPLE
  Lauselohko yhdistää toisiinsa useita lausekkeita siten, että
  ohjelmointikielen rakenne, kuten ~if-else~-rakenne, käsittelee niitä
  yhtenä lausekkeena.
  #+END_QUOTE

  Ohjelmamme näyttää seuraavalta.
  #+BEGIN_SRC processing :exports both
    size (200, 300);

    colorMode (HSB, 100);
    noStroke ();

    float halkaisija;
    if (width > height)
    {
      background (0); // musta tausta
      halkaisija = 100;
    }
    else
    {
      background (63, 100, 100); // sininen tausta
      halkaisija = 50;
    }

    ellipse (width / 2.0, height / 2.0, halkaisija, halkaisija);
  #+END_SRC
** Esimerkki
   Kirjoitetaan ohjelma, joka piirtää suorakulmion \(600\times
   400\)-kokoiseen piirtoikkunaan seuraavasti. Ohjelmassa määritellään
   neljän vakion avulla kaksi piirtoikkunan pistettä $A$ ja $B$:
    - ~X_A~ määrittää pisteen $A$ \(x\)-koordinaatin ja ~Y_A~ saman
      pisteen \(y\)-koordinaatin
    - ~X_B~ määrittää pisteen $B$ \(x\)-koordinaatin ja ~Y_B~ saman
      pisteen \(y\)-koordinaatin.
   Ohjelma piirtää suorakulmion, jonka vastakkaiset kärkipisteet ovat
   $A$ ja \(B.\)

   Suorakulmion piirtämiseen tarvitaan yläkulman koordinaatit sekä
   suorakulmion leveys ja korkeus. Nämä riippuvat siitä, miten $A$ ja
   $B$ sijaitsevat. Alla olevassa kuvassa on piste $A(300, 200$ sekä
   vaihtoehtoja pisteelle \(B.\) Vaakasuunnassa pätee:
   - jos $A$ on \(B\):n oikealla puolella, niin yläkulman
     \(x\)-koordinaatti on ~X_B~ ja leveys on ~(X_A - X_B)~
   - muuten yläkulman \(x\)-koordinaatti on ~X_A~ ja leveys on ~(X_B -
     X_A)~.
   Pystysuunnassa vastaavat ehdot ovat:
   - jos $A$ on \(B\):n alapuolella, niin yläkulman \(y\)-koordinaatti
     on ~Y_B~ ja korkeus on ~(Y_A - Y_B)~
   - muuten yläkulman \(y\)-koordinaatti on ~Y_A~ ja korkeus on
     ~(Y_B - Y_A)~.

   #+BEGIN_SRC asymptote :file suorakulmio-karkipisteista.svg
     int LEVEYS = 600, KORKEUS = 400;
     size (LEVEYS, KORKEUS);
     draw (xscale (LEVEYS) * yscale (KORKEUS) * unitsquare);

     // muunnos Processing-koordinaatistosta perinteiseen koordinaatistoon
     transform T = shift ((0, KORKEUS)) * yscale (-1); 

     pair A = (LEVEYS / 2, KORKEUS / 2);
     dot ("$A$" + ((string) A), T * A);
     real[] osuudet = { .3, .7};
     int i = 0;
     for (real m : osuudet)
       for (real n : osuudet)
         {
        pair B = (m * LEVEYS, n * KORKEUS);
        string BTeksti = "$B$";
        if (++i == 2)
             {
               pair alakulma = minbound (A, B);
               pair ylakulma = maxbound (A, B);
               dot ((string) alakulma, T * alakulma,
         	   unit (T * alakulma - T * A));
               real l = ylakulma.x - alakulma.x; // suorakaiteen leveys
               real k = ylakulma.y - alakulma.y; // suorakaiteen korkeus
               draw (T * shift (alakulma) * scale (l, k) * unitsquare);
               BTeksti += (string) B;
               label ("$" + (string) l + "="
                      + (string) ylakulma.x + "-"
                      + (string) alakulma.x + "$",
                      T * (alakulma -- (ylakulma.x, alakulma.y)));
               label ("$" + (string) k + "="
                      + (string) ylakulma.y + "-"
                      + (string) alakulma.y + "$",
                      T * ((alakulma.x, ylakulma.y) -- alakulma));
             }
             dot (BTeksti, T * B, unit (T * B - T * A));
         }
   #+END_SRC

   #+RESULTS:
   [[file:suorakulmio-karkipisteista.svg]]

   Vastaava ohjelma näyttää seuraavalta.
   #+BEGIN_SRC processing :exports both
     size (600, 400);
     final float X_A = 300, Y_A = 200;
     final float X_B = 180, Y_B = 280;

     float ylakulmaX, ylakulmaY, leveys, korkeus;

     if (X_A > X_B)
     {
       ylakulmaX = X_B;
       leveys = X_A - X_B;
     }
     else
     {
       ylakulmaX = X_A;
       leveys = X_B - X_A;
     }

     if (Y_A > Y_B)
     {
       ylakulmaY = Y_B;
       korkeus = Y_A - Y_B;
     }
     else
     {
       ylakulmaY = Y_A;
       korkeus = Y_B - Y_A;
     }

     rect (ylakulmaX, ylakulmaY, leveys, korkeus);
   #+END_SRC
