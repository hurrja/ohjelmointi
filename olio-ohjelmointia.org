#+INCLUDE: ohjelmointi-kappaleiden-yhteiset-asetukset.org

* Olio-ohjelmointia
** Esimerkki
   Processing-ohjelmissa esiintyy usein pisteitä. Pisteellä on \(x\)-
   ja \(y\)-koordinaatti. Piste voidaan myös piirtää piirtoikkunaan.

   Pisteelle voidaan määritellä oma muuttujatyyppi. Tällaista
   muuttujatyyppiä kutsutaan /luokaksi/. Alla on esimerkki tällaisen
   luokan määrittelystä sekä sen käytöstä ohjelmassa.

   #+NAME: olio-ohjelmointia-piste
   #+BEGIN_SRC processing :exports none
     class Piste
     {
       // tämä funktio "rakentaa" uuden pisteen annetuista koordinaateista
       Piste (float x, float y)
       {
         this.x = x;
         this.y = y;
       }

       // tämä funktio piirtää pisteen
       void piirra ()
       {
         point (x, y);
       }

       float x, y; // pisteen koordinaatit talletetaan näihin muuttujiin
     }
   
   #+END_SRC

   #+BEGIN_SRC processing :exports both :noweb yes
     // luokan Piste määrittely
     <<olio-ohjelmointia-piste>>

     void setup ()
     {
       size (400, 400);
       colorMode (HSB, 100);
       background (0);
       stroke (100);
       noLoop ();
     }

     void draw ()
     {
       for (int i = 0; i < 1000; i++)
       {
         // rakennetaan uusi piste ja talletetaan se muuttujaan p
         Piste p = new Piste (random (width), random (height));
         p.piirra (); // piirretään piste
       }
     }
   #+END_SRC
** Olio-ohjelmoinnin käsitteitä
   #+BEGIN_QUOTE
   - Luokka on ohjelmoijan määrittelemä muuttujatyyppi.
   - Luokassa on funktioita, joita kutsutaan /jäsenfunktioiksi/. Yllä
     olevassa esimerkissä jäsenfunktioita ovat ~Piste()~ sekä
     ~piirra()~.
   - Luokan sisällä olevia muuttujia kutsutaan
     /jäsenmuuttujiksi/. Yllä olevassa esimerkissä jäsenmuuttujia ovat
     ~x~ ja ~y~.
   - Luokan konkreettiset esiintymät ovat /olioita/. Yllä kukin 1000
     pisteestä on olio.
   - Olio luodaan komennolla ~new~ sekä luokan /konstruktorin/
     avulla. Yllä luokan ~Piste~ konstruktori on funktio
     #+BEGIN_EXAMPLE
     Piste (float x, float y)
     #+END_EXAMPLE
     Konstruktorin paluuarvoa ei tarvitse määritellä.
   - Luokan tyyppiä oleva muuttuja on itse asiassa viittaus eli
     /referenssi/ varsinaiseen olioon. Olio on olemassa niin kauan,
     kuin siihen on vähintään yksi viittaus. Olio tuhotaan
     automaattisesti, kun siihen ei enää viitata. Yllä kukin 1000
     pisteestä on talletettuna muuttujaan ~p~ vain vähän aikaa, minkä
     jälkeen ne voidaan tuhota. Tuhoamista ennen kukin pisteistä on
     ehtinyt piirtää itsensä, joten ruudulla pisteet jäävät näkyviin.
   - Olion jäsenmuuttujiin ja -funktioihin viitataan pistemerkin ~.~
     avulla. Yllä lauseke
     #+BEGIN_EXAMPLE
     p.piirra ();
     #+END_EXAMPLE
     kutsuu muuttujaan ~p~ tallennetun olion jäsenfunktiota.
   - Luokan jäsenfunktioiden sisällä sana ~this~ on referenssi
     tämänhetkiseen olioon. Yllä sitä käytetään erottamaan
     jäsenmuuttuja ~this.x~ konstruktorin parametrista ~x~.
   - Luokan tyyppiä oleva muuttuja voi myös olla viittaamatta
     mihinkään olioon. Tällöin muuttujan arvo on tyhjää referenssiä
     tarkoittava ~null~.
   #+END_QUOTE
** Esimerkki
   Määritellään luokka ympyröitä varten. Luokka käyttää aiemmin
   määriteltyä luokkaa pisteille. Tässä esimerkissä huomataan myös,
   että
   - olioita voidaan tallettaa taulukkoon
   - ~for~-silmukasta on olemassa toinen muoto, jonka avulla on
     erityisen näppärä käydä läpi oliotaulukoita; alla silmukassa
     #+BEGIN_EXAMPLE
       for (Ympyra ym : ympyrat)
         ym.piirra ();
     #+END_EXAMPLE
     muuttuja ~ym~ saa vuorotellen kaikki taulukossa ~ympyrat~ olevien
     olioreferenssien arvot.

   #+BEGIN_SRC processing :noweb yes :exports both
     <<olio-ohjelmointia-piste>>

     class Ympyra
     {
       // konstruktori
       Ympyra (Piste keskipiste, float d)
       {
         this.keskipiste = keskipiste;
         this.d = d;
       }

       // jäsenfunktio, joka piirtää
       void piirra ()
       {
         ellipse (keskipiste.x, keskipiste.y, d, d);
       }

       // palauttaa arvon 'true' täsmälleen silloin, jos ympyrät leikkaavat
       boolean leikkaa (Ympyra ym)
       {
         return (dist (keskipiste.x,
                       keskipiste.y,
                       ym.keskipiste.x,
                       ym.keskipiste.y) < d / 2.0 + ym.d / 2.0);
       }

       Piste keskipiste;
       float d;
     }

     void setup ()
     {
       size (600, 400);
       colorMode (HSB, 100);
       noLoop ();
     }

     void draw ()
     {
       Ympyra[] ympyrat = new Ympyra [3]; // taulukko 3 ympyrälle

       // ensimmäinen ympyrä
       ympyrat [0] = new Ympyra (new Piste (200, 300), 150);

       // toinen ympyrä, jolla sama keskipiste kuin ensimmäisellä, mutta
       // eri halkaisija
       ympyrat [1] = new Ympyra (ympyrat [0].keskipiste, 100);

       // kolmas
       ympyrat [2] = new Ympyra (new Piste (150, 230), 30);

       // taustan väri riippuu siitä, leikkaavatko 1. ja 3. ympyrä
       if (ympyrat [2].leikkaa (ympyrat [0]))
         background (0, 100, 100); // punainen
       else
         background (0); // musta

       // käydään ympyrät läpi silmukassa
       for (Ympyra ym : ympyrat)
         ym.piirra ();
     }
   #+END_SRC
** Esimerkki
   Luokka voidaan määritellä myös rekursiivisesti. /Binääripuu/ on
   puumainen rakenne, jossa jokaisessa haarautumiskohdassa on tietoa
   sisältävä /solmu/, ja jokaisesta haarautumiskohdasta lähtee
   korkeintaan kaksi haaraa. Alla määritellään luokka ~Binaaripuu~,
   jonka jokaisessa solmussa on satunnainen kokonaisluku ja kustakin
   haarautumiskohdasta lähtee kaksi haaraa. Puussa on konstruktorille
   annettu määrä tasoja, ja solmun suurimman mahdollisen arvon määrää
   konstruktorin parametri ~suurin~. Tässä on ohjelman piirtämä kuva.

   #+NAME: olio-ohjelmointia-binaaripuu
   #+BEGIN_SRC processing
     class Binaaripuu
     {
       // jäsenmuuttujat
       int arvo; // solmun arvo
       Binaaripuu vasen; // vasen haara
       Binaaripuu oikea; // oikea haara

       // konstruktori
       Binaaripuu (int tasoja, int suurin)
       {
         arvo = floor (random (suurin + 1)); // solmun satunnainen arvo
    
         // rekursion perustapaus
         if (tasoja == 1)
         {
           vasen = null; // ei vasenta haaraa...
           oikea = null; // ... eikä oikeaa
         }
         else
         {
           // rekursioaskel perustapausta kohden
           int tasojaJaljella = tasoja - 1;
           vasen = new Binaaripuu (tasojaJaljella, suurin);
           oikea = new Binaaripuu (tasojaJaljella, suurin);
         }
       }

       void piirra (float x,
                    float y,
                    float askel)
       {
         // tarkistetaan onko haaroja
         if (vasen != null)
         {
           float xVasen = x - askel;
           float xOikea = x + askel;
           float yUusi = y + askel;
           line (x, y, xVasen, yUusi);
           line (x, y, xOikea, yUusi);
           float p = askel / 2;
           vasen.piirra (xVasen, yUusi, p);
           oikea.piirra (xOikea, yUusi, p);
         }

         // piirretään arvo
         text (arvo, x, y);
       }
     }

     void setup ()
     {
       size (800, 400);
       colorMode (HSB, 100);
       textAlign (CENTER, CENTER);
       textSize (20);
       background (0);
       fill (0, 100, 100);
       stroke (30);
       noLoop ();
     }

     void draw ()
     {
       // rakennetaan uusi puu, jossa 5 tasoa
       Binaaripuu puu = new Binaaripuu (5, 100);

       // piirretään puu
       puu.piirra (width / 2.0, 10, 200);
     }
   #+END_SRC

   Kuvan piirtänyt ohjelmakoodi on alla. Huomaa, että
   - luokan rakenne on rekursiivinen: ~Binaaripuu~-olion
     jäsenmuuttujat ~vasen~ ja ~oikea~ ovat myös tyyppiä ~Binaaripuu~,
     eli puun vasen ja oikea haara ovat myös puita
   - konstruktori on rekursiivinen
   - jäsenfunktio ~piirra()~ on rekursiivinen.

   #+BEGIN_SRC processing :exports code :noweb yes
   <<olio-ohjelmointia-binaaripuu>>
   #+END_SRC
** Tehtäviä
   1. Määrittele luokka ~Jana~ ja sille konstruktori sekä jäsenfunktio
      ~piirra()~. Käytä hyväksesi esimerkissä määriteltyä luokkaa
      ~Piste~ sekä sitä, että jana voidaan määrittää kahden
      päätepisteen avulla. Piirrä luokan avulla piirtoikkunaan jana.
** Ratkaisuja
   1. 
      #+BEGIN_SRC processing :noweb yes :exports both
        <<olio-ohjelmointia-piste>>

        class Jana
        {
          Jana (Piste pp1, Piste pp2)
          {
            this.pp1 = pp1;
            this.pp2 = pp2;
          }

          void piirra ()
          {
            line (pp1.x, pp1.y, pp2.x, pp2.y);
          }
  
          Piste pp1, pp2; // päätepisteet
        }

        void setup ()
        {
          size (400, 400);
          noLoop ();
        }

        void draw ()
        {
          Jana j = new Jana (new Piste (100, 150), new Piste (300, 90));
          j.piirra ();
        }
      #+END_SRC
