#+INCLUDE: ohjelmointi-kappaleiden-yhteiset-asetukset.org

* Olio-ohjelmointia
** Esimerkki
   Processing-ohjelmissa esiintyy usein pisteitä. Pisteellä on \(x\)-
   ja \(y\)-koordinaatti. Piste voidaan myös piirtää piirtoikkunaan.

   Pisteelle voidaan määritellä oma muuttujatyyppi. Tällaista
   muuttujatyyppiä kutsutaan /luokaksi/. Alla on esimerkki tällaisen
   luokan määrittelystä sekä sen käytöstä ohjelmassa.

   #+NAME: olio-ohjelmointia-piste
   #+BEGIN_SRC processing :exports none
     class Piste
     {
       // tämä funktio "rakentaa" uuden pisteen annetuista koordinaateista
       Piste (float x, float y)
       {
         this.x = x;
         this.y = y;
       }

       // tämä funktio piirtää pisteen
       void piirra ()
       {
         point (x, y);
       }

       float x, y; // pisteen koordinaatit talletetaan näihin muuttujiin
     }
   
   #+END_SRC

   #+BEGIN_SRC processing :exports both :noweb yes
     // luokan Piste määrittely
     <<olio-ohjelmointia-piste>>

     void setup ()
     {
       size (400, 400);
       colorMode (HSB, 100);
       background (0);
       stroke (100);
       noLoop ();
     }

     void draw ()
     {
       for (int i = 0; i < 1000; i++)
       {
         // rakennetaan uusi piste ja talletetaan se muuttujaan p
         Piste p = new Piste (random (width), random (height));
         p.piirra (); // piirretään piste
       }
     }
   #+END_SRC
** Olio-ohjelmoinnin käsitteitä
   #+BEGIN_QUOTE
   - Luokka on ohjelmoijan määrittelemä muuttujatyyppi.
   - Luokassa on funktioita, joita kutsutaan /jäsenfunktioiksi/. Yllä
     olevassa esimerkissä jäsenfunktioita ovat ~Piste()~ sekä
     ~piirra()~.
   - Luokan sisällä olevia muuttujia kutsutaan
     /jäsenmuuttujiksi/. Yllä olevassa esimerkissä jäsenmuuttujia ovat
     ~x~ ja ~y~.
   - Luokan konkreettiset esiintymät ovat /olioita/. Yllä kukin 1000
     pisteestä on olio.
   - Olio luodaan komennolla ~new~ sekä luokan /konstruktorin/
     avulla. Yllä luokan ~Piste~ konstruktori on funktio
     #+BEGIN_EXAMPLE
     Piste (float x, float y)
     #+END_EXAMPLE
     Konstruktorin paluuarvoa ei tarvitse määritellä.
   - Luokan tyyppiä oleva muuttuja on itse asiassa viittaus eli
     /referenssi/ varsinaiseen olioon. Olio on olemassa niin kauan,
     kuin siihen on vähintään yksi viittaus. Olio tuhotaan
     automaattisesti, kun siihen ei enää viitata. Yllä kukin 1000
     pisteestä on talletettuna muuttujaan ~p~ vain vähän aikaa, minkä
     jälkeen ne voidaan tuhota. Tuhoamista ennen kukin pisteistä on
     ehtinyt piirtää itsensä, joten ruudulla pisteet jäävät näkyviin.
   - Olion jäsenmuuttujiin ja -funktioihin viitataan pistemerkin ~.~
     avulla. Yllä lauseke
     #+BEGIN_EXAMPLE
     p.piirra ();
     #+END_EXAMPLE
     kutsuu muuttujaan ~p~ tallennetun olion jäsenfunktiota.
   - Luokan jäsenfunktioiden sisällä sana ~this~ on referenssi
     tämänhetkiseen olioon. Yllä sitä käytetään erottamaan
     jäsenmuuttuja ~this.x~ konstruktorin parametrista ~x~.
   - Luokan tyyppiä oleva muuttuja voi myös olla viittaamatta
     mihinkään olioon. Tällöin muuttujan arvo on tyhjää referenssiä
     tarkoittava ~null~.
   #+END_QUOTE
** Esimerkki
   Määritellään luokka ympyröitä varten. Luokka käyttää aiemmin
   määriteltyä luokkaa pisteille. Tässä esimerkissä huomataan myös,
   että
   - olioita voidaan tallettaa taulukkoon
   - ~for~-silmukasta on olemassa toinen muoto, jonka avulla on
     erityisen näppärä käydä läpi oliotaulukoita; alla silmukassa
     #+BEGIN_EXAMPLE
       for (Ympyra ym : ympyrat)
         ym.piirra ();
     #+END_EXAMPLE
     muuttuja ~ym~ saa vuorotellen kaikki taulukossa ~ympyrat~ olevien
     olioreferenssien arvot.

   #+BEGIN_SRC processing :noweb yes :exports both
     <<olio-ohjelmointia-piste>>

     class Ympyra
     {
       // konstruktori
       Ympyra (Piste keskipiste, float d)
       {
         this.keskipiste = keskipiste;
         this.d = d;
       }

       // jäsenfunktio, joka piirtää
       void piirra ()
       {
         ellipse (keskipiste.x, keskipiste.y, d, d);
       }

       // palauttaa arvon 'true' täsmälleen silloin, jos ympyrät leikkaavat
       boolean leikkaa (Ympyra ym)
       {
         return (dist (keskipiste.x,
                       keskipiste.y,
                       ym.keskipiste.x,
                       ym.keskipiste.y) < d / 2.0 + ym.d / 2.0);
       }

       Piste keskipiste;
       float d;
     }

     void setup ()
     {
       size (600, 400);
       colorMode (HSB, 100);
       noLoop ();
     }

     void draw ()
     {
       Ympyra[] ympyrat = new Ympyra [3]; // taulukko 3 ympyrälle

       // ensimmäinen ympyrä
       ympyrat [0] = new Ympyra (new Piste (200, 300), 150);

       // toinen ympyrä, jolla sama keskipiste kuin ensimmäisellä, mutta
       // eri halkaisija
       ympyrat [1] = new Ympyra (ympyrat [0].keskipiste, 100);

       // kolmas
       ympyrat [2] = new Ympyra (new Piste (150, 230), 30);

       // taustan väri riippuu siitä, leikkaavatko 1. ja 3. ympyrä
       if (ympyrat [2].leikkaa (ympyrat [0]))
         background (0, 100, 100); // punainen
       else
         background (0); // musta

       // käydään ympyrät läpi silmukassa
       for (Ympyra ym : ympyrat)
         ym.piirra ();
     }
   #+END_SRC
** Esimerkki
   Luokka voidaan määritellä myös rekursiivisesti. /Binääripuu/ on
   puumainen rakenne, joka koostuu /solmuista/ sekä niiden välisistä
   yhteyksistä. Jokaisesta solmusta lähtee korkeintaan kaksi haaraa
   alempana oleviin solmuihin. Alimpia solmuja kutsutaan /lehdiksi/.

   Alla määritellään luokka ~Binaaripuu~, jonka jokaisessa lehdessä on
   satunnainen kokonaisluku ja kustakin ylemmästä solmusta lähtee
   kaksi haaraa. Solmun arvo on välittömästi solmun alla olevien
   solmujen arvojen summa. Kunkin solmun arvo on siis solmun alla
   olevien lehtien arvojen summa. Luokan konstruktorille annetaan puun
   tasojen määrä (alla olevassa kuvassa 5), ja lehden suurimman
   mahdollisen arvon määrää konstruktorin parametri ~suurin~. Tässä on
   ohjelman piirtämä kuva.

   #+NAME: olio-ohjelmointia-binaaripuu
   #+BEGIN_SRC processing
     class Binaaripuu
     {
       // jäsenmuuttujat
       int arvo; // solmun arvo
       Binaaripuu vasen; // vasen haara
       Binaaripuu oikea; // oikea haara

       // konstruktori
       Binaaripuu (int tasoja, int suurin)
       {
         // rekursion perustapaus: lehti
         if (tasoja == 1)
         {
           arvo = floor (random (suurin + 1)); // lehden satunnainen arvo
           vasen = null; // ei vasenta haaraa...
           oikea = null; // ... eikä oikeaa
         }
         else
         {
           // rekursioaskel perustapausta kohden
           int tasojaJaljella = tasoja - 1;
           vasen = new Binaaripuu (tasojaJaljella, suurin);
           oikea = new Binaaripuu (tasojaJaljella, suurin);

           // solmun arvo on alapuiden arvojen summa
           arvo = vasen.arvo + oikea.arvo; 
         }
       }

       void piirra (float x,
                    float y,
                    float askel)
       {
         // tarkistetaan onko haaroja
         if (vasen != null)
         {
           float xVasen = x - askel;
           float xOikea = x + askel;
           float yUusi = y + askel;
           line (x, y, xVasen, yUusi);
           line (x, y, xOikea, yUusi);
           float p = askel / 2;
           vasen.piirra (xVasen, yUusi, p);
           oikea.piirra (xOikea, yUusi, p);
         }

         // piirretään arvo
         text (arvo, x, y);
       }
     }

     void setup ()
     {
       size (800, 400);
       colorMode (HSB, 100);
       textAlign (CENTER, CENTER);
       textSize (20);
       background (0);
       fill (0, 100, 100);
       stroke (30);
       noLoop ();
     }

     void draw ()
     {
       // rakennetaan uusi puu, jossa 5 tasoa
       Binaaripuu puu = new Binaaripuu (5, 100);

       // piirretään puu
       puu.piirra (width / 2.0, 10, 200);
     }
   #+END_SRC

   Kuvan piirtänyt ohjelmakoodi on alla. Huomaa, että
   - luokan rakenne on rekursiivinen: ~Binaaripuu~-olion
     jäsenmuuttujat ~vasen~ ja ~oikea~ ovat myös tyyppiä ~Binaaripuu~,
     eli puun vasen ja oikea haara ovat myös puita
   - konstruktori on rekursiivinen
   - lehdellä ei ole vasenta eikä oikeaa alihaaraa, joten niiden
     arvoksi asetetaan puuttuvaa oloita tarkoittava ~null~
   - jäsenfunktio ~piirra()~ on rekursiivinen.

   #+BEGIN_SRC processing :exports code :noweb yes
   <<olio-ohjelmointia-binaaripuu>>
   #+END_SRC
** Tehtäviä
   1. Määrittele luokka ~Jana~ ja sille konstruktori sekä jäsenfunktio
      ~piirra()~. Käytä hyväksesi esimerkissä määriteltyä luokkaa
      ~Piste~ sekä sitä, että jana voidaan määrittää kahden
      päätepisteen avulla. Piirrä luokan avulla piirtoikkunaan jana.
   2. Määrittele luokka ~Kolmio~ ja sille konstruktori sekä
      jäsenfunktio ~piirra()~. Käytä hyväksesi esimerkissä määriteltyä
      luokkaa ~Piste~. Piirrä luokan avulla piirtoikkunaan 50
      eriväristä, satunnaisen kokoista kolmiota.
   3. Määrittele luokka ~NKulmio~ ja sille konstruktori sekä
      jäsenfunktio ~piirra()~. Käytä hyväksesi yllä kirjoitettuja
      luokkia ~Piste~ sekä ~Jana~. Luokan ~NKulmio~ konstruktorin
      ainoa parametri on pistetaulukko, jossa olevat pisteet
      määrittävät \(n\)-kulmion kärkipisteiden sijainnin kierrettäessä
      monikulmiota myötä- tai vastapäivään.  Piirrä luokan avulla
      viisikulmio, jonka kärkipisteet ovat itse määrittelemissäsi
      koordinaateissa.
** Ratkaisuja
   1. 
      #+NAME: olio-ohjelmointia-jana
      #+BEGIN_SRC processing :exports none :noweb yes
        <<olio-ohjelmointia-piste>>

        class Jana
        {
          Jana (Piste pp1, Piste pp2)
          {
            this.pp1 = pp1;
            this.pp2 = pp2;
          }

          void piirra ()
          {
            line (pp1.x, pp1.y, pp2.x, pp2.y);
          }
  
          Piste pp1, pp2; // päätepisteet
        }
      #+END_SRC

      #+BEGIN_SRC processing :noweb yes :exports both
        <<olio-ohjelmointia-jana>>

        void setup ()
        {
          size (400, 400);
          noLoop ();
        }

        void draw ()
        {
          Jana j = new Jana (new Piste (100, 150), new Piste (300, 90));
          j.piirra ();
        }
      #+END_SRC
   2. 
      #+BEGIN_SRC processing :noweb yes :exports both
        <<olio-ohjelmointia-jana>>

        class NKulmio
        {
          NKulmio (Piste[] pisteet)
          {
            this.pisteet = pisteet;
            n = pisteet.length;
          }

          void piirra ()
          {
            // piirretään janat pisteiden välille
            for (int i = 0; i < n; i++)
            {
              // janan ensimmäinen päätepiste
              Piste p1 = pisteet [i];

              // toinen päätepiste on seuraava taulukon piste paitsi jos
              // ensimmäinen päätepiste on taulukon viimeinen, jolloin toinen
              // päätepiste on taulukon ensimmäinen
              Piste p2;
              if (i == n - 1)
                p2 = pisteet [0];
              else
                p2 = pisteet [i + 1];

              Jana j = new Jana (p1, p2);
              j.piirra ();
            }
          }

          Piste[] pisteet;
          int n; // monikulmion kärkipisteiden lukumäärä
        }

        void setup ()
        {
          size (400, 400);
          noLoop ();
        }

        void draw ()
        {
          // viisikulmion kärkipisteet
          Piste[] pisteet = new Piste [5];
          pisteet [0] = new Piste (0, 0);
          pisteet [1] = new Piste (100, 20);
          pisteet [2] = new Piste (200, 70);
          pisteet [3] = new Piste (300, 170);
          pisteet [4] = new Piste (150, 320);
          NKulmio kulmio = new NKulmio (pisteet);

          kulmio.piirra ();
        }
      #+END_SRC
