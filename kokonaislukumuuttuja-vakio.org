#+INCLUDE: ohjelmointi-kappaleiden-yhteiset-asetukset.org

* Kokonaislukumuuttuja ja -vakio
** Liukuluvun ja kokonaisluvun ero
   Tietokoneessa liukulukujen eli ~float~-tyyppisten muuttujien esitys
   poikkeaa kokonaislukujen esityksestä. Täten Processing kielen luvut
   ~1~ ja ~1.0~ esitetään tietokoneessa eril lailla, joten ne eivät
   välttämättä ole täsmälleen yhtä suuria. Niinpä seuraavassa
   ohjelmassa /ei voida taata/, että ehto ~(a == 1)~ on tosi, vaikka
   muuttujan ~a~ arvo on kolmen desimaalin tarkkuudella ~1.000~.

   #+BEGIN_SRC processing :exports both
     size (200, 200);
     colorMode (HSB, 100);

     float a = 0.1; // muuttujan a arvo alussa

     // lisätään 0.1 niin kauan, kun a < 0.99
     while (a < 0.99)
       a = a + 0.1;
     // tämän jälkeen muuttujan a arvo lienee 1

     if (a == 1) // MUTTA tämä ehto voi olla tosi tai sitten ei
       background (30, 100, 100); // vihreä jos a:n arvo on 1
     else
       background (0, 100, 100); // punainen, jos a:n arvo ei ole 1

     // piirretään vielä luku a tekstinä kuvan keskelle
     fill (0);
     textSize (40); // selitys alla
     textAlign (CENTER, CENTER); // selitys alla
     text (a, width / 2.0, height / 2.0); // selitys alla
   #+END_SRC

   #+BEGIN_QUOTE
   Tietokoneohjelmassa liukuluku ~1.0~ ja kokonaisluku ~1~ eivät
   välttämättä ole täsmälleen sama luku. Tällä on merkitystä
   erityisesti silloin, kun lukuja vertaillaan jollain
   vertailuoperaattoreista ~==~, ~!=~, ~>=~ tai ~<=~, ~>~ tai ~<~.
   #+END_QUOTE
** Kokonaislukumuuttuja ja -vakio
   #+BEGIN_QUOTE
   Jos jokin muuttuja tai vakio on kokonaisluku, määrittelyssä
   käytetään ~float~ sanan sijasta sanaa ~int~, joka tulee englannin
   kielen kokonaislukua tarkoittavasta sanasta /integer/. Tällöin on
   syytä muistaa aiemmin esitetyt kokonaislukujen jakolaskun
   ominaisuudet: kahden kokonaisluvun jakolaskun tulos on aina
   kokonaisluku.
   #+END_QUOTE
** Luvun piirtäminen tekstinä piirtoikkunaan
   Luku voidaan piirtää tekstinä funktion ~text()~ avulla. Tekstin
   kokoa voidaan muuttaa funktiolla ~textSize()~, ja tekstin
   sijoittelua suhteessa annettuun kohtaan funktiolla
   ~textAlign()~. Alla esimerkki.

   #+BEGIN_SRC processing :exports both
     size (200, 200);
     colorMode (HSB, 100);
     background (0); // musta tausta
     fill (100); // valkoinen teksti

     textSize (60); // tekstin koko 30 pikseliä

     // tekstin keskikohta piirretään annettuun kohtaan
     textAlign (CENTER, CENTER);

     text (100 / 6, 100, 100); // jakolaskun tulos kokonaislukuosa
   #+END_SRC
** Esimerkki
   Piirretään \(1000\times 100\)-kokoiseen ikkunaan mustalle taustalle
   25 ensimmäistä positiivista kokonaislukua vasemmalta
   oikealle. Luvut ovat pystysuunnassa piirtoikkunan keskellä. Luku 10
   on punainen, muut ovat valkoisia. Lukujen keskipisteiden väli on
   30, joka on myös vasemmanpuoleisen luvun
   \(x\)-koordinaatti. Tekstin koko on 16 pikseliä.

   #+NAME: kokonaisluku-luvut-rivissa
   #+BEGIN_SRC processing
     size (1000, 100);
     colorMode (HSB, 100);
     background (0); // musta tausta
     textSize (16); // tekstin koko
     textAlign (CENTER, CENTER); // tekstin keskikohta annetuissa koordinaateissa

     final float VALI = 30; // tekstin keskipisteiden väli
     float x = VALI; // tekstin keskipisteen x-koordinaatti
     final float Y = height / 2.0; // tekstin keskipisteen Y-koordinaatti

     int n = 1; // piirrettävä numero

     // piirretään 25 numeroa
     while (n <= 25) // turvallista vertailla, kun n on kokonaisluku
     {
       if (n == 10) // turvallista vertailla
         fill (0, 100, 100); // punainen teksti
       else
         fill (100); // valkoinen teksti
    
       // luku tekstinä
       text (n, x, Y);

       x = x + VALI; // seuraavan keskipisteen x
       n = n + 1; // seuraava numero
     }
   #+END_SRC

   #+BEGIN_SRC processing :exports code :noweb yes
   <<kokonaisluku-luvut-rivissa>>
   #+END_SRC

   Esimerkissä myös vakio ~VALI~ sekä muuttuja ~x~ /voitaisiin/
   määritellä kokonaisluvuiksi, koska ne saavat vain
   kokonaislukuarvoja. Muuttuja ~n~ on kuitenkin /pakko/ määritellä
   kokonaislukuna, jotta vertailut onnistuvat varmasti.

** Milloin käytetään kokonaislukumuuttujaa tai -vakiota?
   #+BEGIN_QUOTE
   Kokonaislukumuuttujaa täytyy käyttää silloin, kun
   - muuttuja saa vain kokonaislukuarvoja ja
   - muuttujaa käytetään myös muuhun kuin piirtokoordinaattien
     laskemiseen (kuten muuttujan arvon vertaamiseen kokonaislukuun).
   Kokonaislukuvakiota täytyy käyttää samanlaisissa tilanteissa.

   Liukulukumuuttujaa (tai vakiota) täytyy käyttää silloin, kun
   muuttuja saa desimaalilukuarvoja.

   Muissa tapauksissa ohjelmoija voi valita, haluaako hän käyttää
   kokonaisluku- vai liukulukumuuttujaa. Kokonaisluvut vievät vähemmän
   tilaa tietokoneen muistista, ja niillä laskeminen on nopeampaa.
   #+END_QUOTE
** Jakojäännös
   #+BEGIN_QUOTE
   Jos ~n~ ja ~m~ ovat epänegatiivisia kokonaislukuja ja ~m~\(\,\neq
   0\), niin Processing-kielen laskutoimitus ~n % m~ antaa
   jakojäännöksen, kun luku ~n~ jaetaan luvulla ~m~.
   #+END_QUOTE
** Esimerkki
   #+BEGIN_SRC processing :exports both
     size (800, 200);

     final float Y = height / 2.0; // tekstin y-koordinaatti

     textSize (30);
     textAlign (CENTER, CENTER);

     text (49 % 7, 100, Y); // jakojäännös, kun 49 jaetaan luvulla 7
     text (7 % 5, 200, Y); 
     text (5 % 7, 300, Y);
     text (0 % 2, 400, Y);
     text (1 % 2, 500, Y);
     text (2 % 2, 600, Y);
     text (3 % 2, 700, Y);
   #+END_SRC
   Esimerkin viimeisistä luvuista huomataan, että kokonaisluvun
   jakojäännös jaettaessa luvulla 2 on
   - 0, jos luku on parillinen
   - 1, jos luku on pariton.
** Muuttujan arvon muuttaminen yhdellä
   #+BEGIN_QUOTE
   Koska ohjelmissa joudutaan usein kasvattamaan muuttujan arvoa
   yhdellä, tätä varten on olemassa erillinen merkintä. Merkintä ~n++~
   tarkoittaa samaa kuin ~n = n + 1.~

   Vastaavasti merkintä ~n--~ tarkoittaa samaa kuin ~n = n - 1.~
   #+END_QUOTE
** Esimerkki
   Piirretään alla olevan kuvan mukaisesti mustalle taustalle
   mahdollisimman monta ympyrää piirtoikkunaan. Ympyröiden halkaisija
   on vakio ~HALKAISIJA~.
   #+NAME: vakio-siniset-keltaiset-ympyrat
   #+BEGIN_SRC processing
     size (990, 100);
     colorMode (HSB, 100);
     background (0); // musta tausta
     noStroke (); // ei ympyröiden ääriviivoja

     final int HALKAISIJA = 20; // ympyröiden halkaisija (kokonaisluku)
     final float Y = height / 2.0; // keskipisteiden y-koordinaatti

     // ympyröiden lukumäärä; huom. kokonaisluvun jakaminen kokonaisluvulla
     // antaa tuloksena kokonaisluvun: kuinka monta kertaa halkaisija
     // mahtuu leveyteen
     int ympyroita = width / HALKAISIJA;

     int n = 1; // kuinka monetta ympyrää piirretään

     while (n <= ympyroita)
     {
       if (n % 2 == 1) // ensimmäinen ja muut parittomat sinisellä
         fill (62, 100, 100);
       else
         fill (17, 100, 100);

       ellipse ((n - 0.5) * HALKAISIJA, Y, HALKAISIJA, HALKAISIJA);
       n++; // kasvatetaan järjestysnumeroa
     }
   #+END_SRC

   Alla olevassa ohjelmakoodissa on seuraavia ideoita.
   - ~HALKAISIJA~ määritellään kokonaislukuna, jotta kuvaan mahtuvien
     ympyröiden määrä on helppo laskea kokonaislukujen jakolaskuna
     ~width / HALKAISIJA~.
   - Ensin lasketaan piirtoikkunaan mahtuvien ympyröiden lukumäärä
     muuttujaan ~ympyroita~.
   - Ympyrä on sininen piirrettäessä ympyrää, jonka järjestysnumero on
     pariton.
   - Piirrettävän ympyrän keskipisteen vasemmalla puolella ovat
     aiemmin piirretyt ympyrät sekä puolet nyt piirrettävän ympyrän
     halkaisijasta. Niinpä piirrettävän ympyrän keskipisteen
     \(x\)-koordinaatti on ~((n - 0.5) * HALKAISIJA)~.

   #+BEGIN_SRC processing :noweb yes :exports code
   <<vakio-siniset-keltaiset-ympyrat>>
   #+END_SRC
** Esimerkki
   Piirretään alla oleva sahalaitakuvio piirtoikkunaan, jonka koko on
   \(400\times 400\). Origosta alkavan janan pituus on 10, ja kukin
   seuraava jana on 10 prosenttia edellistä pidempi. Viivaan voidaan
   käyttää yhteensä korkeintaan 700 pikseliä. Kulmapisteissä
   päällekkäin meneviä yksittäisiä pikseleitä ei tarvitse ottaa
   huomioon.

   #+NAME: kokonaisluku-sahalaita-pitenevin-askelin
   #+BEGIN_SRC processing
     size (400, 400);

     colorMode (HSB, 100);
     background (0); // musta tausta
     stroke (0, 100, 100); // punaiset viivat

     float askel = 10; // seuraavaksi otettavan askeleen pituus
     float pikseleitaJaljella = 700; // jäljellä olevien pikselien määrä

     float x = 0, y = 0; // viivan kärkipiste, alussa origossa
     int xSuunta = 1, ySuunta = 0; // määräävät seuraavan askeleen suunnan

     // niin kauan kun pikseleitä on jäljellä riittävästi...
     while (pikseleitaJaljella >= askel)
     {
       // lasketaan viivan seuraava kärkipiste
       float xSeuraava = x + xSuunta * askel;
       float ySeuraava = y + ySuunta * askel;

       line (x, y, xSeuraava, ySeuraava); // piirretään viiva

       // päivitetään viivan kärkipisteen koordinaatit
       x = xSeuraava;
       y = ySeuraava;
       
       // vähennetään jäljellä olevien pikseleiden määrää
       pikseleitaJaljella = pikseleitaJaljella - askel;

       askel = 1.1 * askel; // kasvatetaan askelta 10 prosenttia
  
       // päätellään seuraavan askeleen suunta
       if (xSuunta == 1)
       {
         xSuunta = 0;
         ySuunta = 1;
       }
       else
       {
         xSuunta = 1;
         ySuunta = 0;
       }
     }
   #+END_SRC

   Viivan suunta muuttuu kierroksesta toiseen. Suunta ilmaistaan
   ohjelmassa kokonaislukumuuttujien ~xSuunta~ ja ~ySuunta~
   avulla. Tällaisten muuttujien käytön avulla voidaan tehtävissä
   kirjoittaa myös monimutkaisempia ohjelmia. Jos muuttujan ~xSuunta~
   arvo on
   - 1, liikutaan oikealle
   - 0, ei liikuta \(x\)-akselin suunnassa.
   Vastaavasti jos muuttujan ~ySuunta~ arvo on
   - 1, liikutaan alaspäin
   - 0, ei liikuta \(y\)-akselin suunnassa.
   Näiden muuttujien arvot voidaan päivittää kullakin kierroksella
   huomaamalla, että 
   - jos muuttujan ~xSuunta~ arvo on 1, seuraavalla kierroksella
     liikutaan alas
   - muuten liikutaan seuraavalla kierroksella oikealle.

   #+BEGIN_SRC processing :exports code :noweb yes
   <<kokonaisluku-sahalaita-pitenevin-askelin>>
   #+END_SRC

** Tehtävät
   1. Piirrä alla oleva kuvio ~while~-silmukan avulla piirtämällä
      ensin suuri musta ympyrä, sen päälle pienempi valkoinen ympyrä,
      jonka päälle edelleen pienempi musta ympyrä. Piirtoikkuna on
      neliön muotoinen, ja kuvan tulee skaalautua piirtoikkunan
      mukana. Piirretyn ympyrän halkaisija pienenee 10 pikseliä
      kullakin askeleella. 

      #+NAME: kokonaisluku-tikkataulu
      #+BEGIN_SRC processing
        size (400, 400);
        colorMode (HSB, 100);
        noStroke ();

        // keskipisteen koordinaatti (sekä x että y)
        final float K = width / 2.0; 

        float halkaisija = width; // ympyrän halkaisija

        // piirretyn ympyrän kirkkaus, vuorotellen 0 ja 100
        float kirkkaus = 0; 

        while (halkaisija > 0)
        {
          fill (kirkkaus);
          ellipse (K, K, halkaisija, halkaisija);

          halkaisija = halkaisija - 10;
          if (kirkkaus == 100)
            kirkkaus = 0;
          else
            kirkkaus = 100;
        }
      #+END_SRC
   2. Piirrä \(400\times 400\)-kokoiseen piirtoikkunaan alla oleva
      murtoviiva. Viiva alkaa piirtoikkunan keskeltä. Ensimmäisen,
      piirtoikkunan keskeltä alkavan janan pituus on 5, ja seuraava
      jana on 20 prosenttia edellistä pidempi. Viivaan voidaan käyttää
      yhteensä korkeintaan 1500 pikseliä. Kulmapisteissä päällekkäin
      meneviä yksittäisiä pikseleitä ei tarvitse ottaa huomioon.

      Jos kullakin askeleella piirrettävän janan suunta ilmaistaan
      yllä olevan esimerkin tapaan muuttujien ~xSuunta~ ja ~ySuunta~
      avulla, niin nämä muuttujat saavat seuraavia arvoja:
      #+BEGIN_CENTER
      | askeleen no | 1 | 2 |  3 |  4 | 5 | 6 |  7 |  8 |
      |-------------+---+---+----+----+---+---+----+----|
      | ~xSuunta~   | 0 | 1 |  0 | -1 | 0 | 1 |  0 | -1 |
      | ~ySuunta~   | 1 | 0 | -1 |  0 | 1 | 0 | -1 |  0 |
      #+END_CENTER

      #+NAME: kokonaisluku-laajeneva-spiraali
      #+BEGIN_SRC processing
        size (400, 400);
        colorMode (HSB, 100);
        background (0);
        stroke (100);
        float x = width / 2.0, y = height / 2.0;
        float pikseleitaJaljella = 1500;
        float xSuunta = 0, ySuunta = 1;
        float askel = 5;

        while (pikseleitaJaljella >= askel)
        {
          float xSeuraava = x + xSuunta * askel;
          float ySeuraava = y + ySuunta * askel;
          line (x, y, xSeuraava, ySeuraava);

          x = xSeuraava;
          y = ySeuraava;

          pikseleitaJaljella = pikseleitaJaljella - askel;
          askel = askel * 1.2;

          if (xSuunta == 0)
          {
            if (ySuunta == 1)
              xSuunta = 1;
            else
              xSuunta = -1;

            ySuunta = 0;
          }
          else
          {
            if (xSuunta == 1)
              ySuunta = -1;
            else
              ySuunta = 1;

            xSuunta = 0;
          }
        }
   #+END_SRC
** Ratkaisuja
   1. 
      #+BEGIN_SRC processing :exports code :noweb yes
      <<kokonaisluku-tikkataulu>>
      #+END_SRC
   2. 
       #+BEGIN_SRC processing :exports code :noweb yes
       <<kokonaisluku-laajeneva-spiraali>>
       #+END_SRC
   
